<html lang="en">
<head>
     <meta charset="UTF-8">
     <meta name="viewport" content="width=device-width, initial-scale=1.0">
     <title>Endless Runner Game</title>
     <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
</head>
<body class="bg-gradient-to-b from-sky-300 to-green-300 min-h-screen overflow-hidden">
     <!-- Game Container -->
     <div id="gameContainer" class="relative w-full h-screen">
          <!-- UI Elements -->
          <div class="absolute top-4 left-4 z-10">
               <div class="bg-black bg-opacity-50 text-white p-4 rounded-lg">
                    <div class="text-xl font-bold">Score: <span id="score">0</span></div>
                    <div class="text-sm">High Score: <span id="highScore">0</span></div>
                    <div class="text-sm mt-2">
                         <div>Obstacle Hits: <span id="obstacleHits">0</span>/3</div>
                         <div id="slowdownIndicator" class="text-red-400 hidden">SLOWED DOWN!</div>
                    </div>
               </div>
          </div>

          <!-- Game Over Screen -->
          <div id="gameOverScreen" class="absolute inset-0 bg-black bg-opacity-75 flex items-center justify-center z-20 hidden">
               <div class="bg-white p-8 rounded-lg text-center">
                    <h2 class="text-3xl font-bold mb-4 text-red-600">Game Over!</h2>
                    <p class="text-xl mb-2">Final Score: <span id="finalScore">0</span></p>
                    <p class="text-lg mb-4">High Score: <span id="finalHighScore">0</span></p>
                    <button id="restartBtn" class="bg-blue-500 hover:bg-blue-600 text-white px-6 py-3 rounded-lg font-bold">
                         Play Again
                    </button>
               </div>
          </div>

          <!-- Start Screen -->
          <div id="startScreen" class="absolute inset-0 bg-black bg-opacity-75 flex items-center justify-center z-20">
               <div class="bg-white p-8 rounded-lg text-center">
                    <h1 class="text-4xl font-bold mb-4 text-blue-600">Endless Runner</h1>
                    <p class="text-lg mb-4">Press SPACEBAR to jump and avoid obstacles!</p>
                    <button id="startBtn" class="bg-green-500 hover:bg-green-600 text-white px-6 py-3 rounded-lg font-bold">
                         Start Game
                    </button>
               </div>
          </div>

          <!-- Game Canvas -->
          <canvas id="gameCanvas" class="absolute inset-0 w-full h-full"></canvas>
     </div>

     <script>
          class EndlessRunner {
               constructor() {
                    this.canvas = document.getElementById('gameCanvas');
                    this.ctx = this.canvas.getContext('2d');
                    this.canvas.width = window.innerWidth;
                    this.canvas.height = window.innerHeight;
                    
                    this.gameState = 'start'; // start, playing, gameOver
                    this.score = 0;
                    this.highScore = localStorage.getItem('highScore') || 0;
                    this.gameSpeed = 4;
                    this.baseGameSpeed = 4;
                    this.gravity = 0.8;
                    this.slowdownTimer = 0;
                    this.hitTimestamps = [];
                    this.hitFlash = 0;
                    this.lastHitTime = 0; // Track when the last obstacle was hit
                    
                    this.ground = this.canvas.height - 100;
                    
                    // Player properties
                    this.player = {
                         x: 100,
                         y: this.ground - 60,
                         width: 40,
                         height: 60,
                         velocityY: 0,
                         jumping: false,
                         runFrame: 0
                    };
                    
                    this.obstacles = [];
                    this.monster = null; // Single monster
                    this.clouds = [];
                    
                    this.obstacleTimer = 0;
                    this.cloudTimer = 0;
                    
                    this.keys = {};
                    
                    this.setupEventListeners();
                    this.generateClouds();
                    this.updateHighScore();
                    this.gameLoop();
               }
               
               setupEventListeners() {
                    document.addEventListener('keydown', (e) => {
                         this.keys[e.code] = true;
                         if (e.code === 'Space') {
                              e.preventDefault();
                              this.jump();
                         }
                    });
                    
                    document.addEventListener('keyup', (e) => {
                         this.keys[e.code] = false;
                    });
                    
                    document.getElementById('startBtn').addEventListener('click', () => {
                         this.startGame();
                    });
                    
                    document.getElementById('restartBtn').addEventListener('click', () => {
                         this.restartGame();
                    });
                    
                    // Handle canvas clicks for jump
                    this.canvas.addEventListener('click', () => {
                         if (this.gameState === 'playing') {
                              this.jump();
                         }
                    });
               }
               
               startGame() {
                    this.gameState = 'playing';
                    document.getElementById('startScreen').classList.add('hidden');
                    this.spawnMonster(); // Spawn the single monster
               }
               
               restartGame() {
                    this.gameState = 'playing';
                    this.score = 0;
                    this.gameSpeed = 4;
                    this.baseGameSpeed = 4;
                    this.slowdownTimer = 0;
                    this.hitTimestamps = [];
                    this.hitFlash = 0;
                    this.lastHitTime = 0;
                    this.obstacles = [];
                    this.monster = null;
                    this.player.y = this.ground - 60;
                    this.player.velocityY = 0;
                    this.player.jumping = false;
                    this.obstacleTimer = 0;
                    document.getElementById('gameOverScreen').classList.add('hidden');
                    this.spawnMonster(); // Spawn the single monster
               }
               
               jump() {
                    if (this.gameState === 'playing' && !this.player.jumping) {
                         this.player.velocityY = -18;
                         this.player.jumping = true;
                    }
               }
               
               updatePlayer() {
                    // Apply gravity
                    this.player.velocityY += this.gravity;
                    this.player.y += this.player.velocityY;
                    
                    // Ground collision
                    if (this.player.y >= this.ground - this.player.height) {
                         this.player.y = this.ground - this.player.height;
                         this.player.velocityY = 0;
                         this.player.jumping = false;
                    }
                    
                    // Running animation
                    this.player.runFrame += 0.3;
                    if (this.player.runFrame >= 4) this.player.runFrame = 0;
               }
               
               spawnObstacle() {
                    if (this.obstacleTimer <= 0) {
                         this.obstacles.push({
                              x: this.canvas.width,
                              y: this.ground - 40,
                              width: 30,
                              height: 40,
                              type: Math.random() > 0.5 ? 'cactus' : 'rock'
                         });
                         this.obstacleTimer = Math.random() * 100 + 80;
                    }
                    this.obstacleTimer--;
               }
               
               spawnMonster() {
                    // Only spawn one monster if it doesn't exist
                    if (!this.monster) {
                         // Spawn monster from the left side (behind the player)
                         this.monster = {
                              x: -100, // Spawn from left side
                              y: this.ground - 50,
                              width: 35,
                              height: 50,
                              baseSpeed: 2.5,
                              speed: 2.5,
                              frame: 0,
                              catchDistance: 40
                         };
                    }
               }
               
               generateClouds() {
                    for (let i = 0; i < 5; i++) {
                         this.clouds.push({
                              x: Math.random() * this.canvas.width,
                              y: Math.random() * 200 + 50,
                              width: Math.random() * 60 + 40,
                              height: Math.random() * 30 + 20,
                              speed: Math.random() * 0.5 + 0.2
                         });
                    }
               }
               
               updateObstacles() {
                    this.obstacles = this.obstacles.filter(obstacle => {
                         obstacle.x -= this.gameSpeed;
                         return obstacle.x + obstacle.width > 0;
                    });
               }
               
               updateMonster() {
                    if (!this.monster) return;
                    
                    // First, move monster with the game speed (same as obstacles)
                    // This keeps the monster moving at the same pace as the world
                    this.monster.x -= this.gameSpeed;
                    
                    // Calculate distance to player
                    let distanceToPlayer = Math.abs(this.monster.x - this.player.x);
                    
                    // Monster gets progressively closer with each obstacle hit
                    let hitCount = this.hitTimestamps ? this.hitTimestamps.length : 0;
                    let baseDistance = 150; // Start with more distance
                    let distanceReduction = 40; // Reduce distance by 40 pixels per hit
                    let chaseDistance = Math.max(20, baseDistance - (hitCount * distanceReduction));
                    let isDeadly = hitCount >= 3;
                    
                    // Additional movement toward player (on top of the base game speed movement)
                    if (this.monster.x > this.player.x + chaseDistance) {
                         // Monster is to the right of player, move left toward player (additional movement)
                         this.monster.x -= this.monster.speed;
                    } else if (this.monster.x < this.player.x - chaseDistance) {
                         // Monster is to the left of player, move right toward player (additional movement)
                         this.monster.x += this.monster.speed;
                    }
                    
                    // If monster goes too far off-screen to the left, respawn it from the left again
                    if (this.monster.x < -200) {
                         this.monster.x = -100;
                    }
                    // If monster goes too far off-screen to the right, respawn it from the left
                    if (this.monster.x > this.canvas.width + 200) {
                         this.monster.x = -100;
                    }
                    
                    // Vertical following - gets closer with more hits
                    let verticalDistance = Math.abs(this.monster.y - this.player.y);
                    let verticalChaseDistance = Math.max(10, 35 - (hitCount * 8)); // Reduce from 35 to 10 pixels
                    if (this.monster.y > this.player.y + verticalChaseDistance && this.monster.y > this.ground - 50) {
                         this.monster.y -= 2;
                    } else if (this.monster.y < this.player.y - verticalChaseDistance && this.monster.y < this.ground - 50) {
                         this.monster.y += 2;
                    }
                    
                    // Monster speed increases progressively with each hit
                    let baseSpeedMultiplier = 1.0 + (hitCount * 0.5); // +0.5x speed per hit
                    if (this.slowdownTimer > 0) {
                         // Additional speed boost when player is slowed
                         this.monster.speed = this.monster.baseSpeed * baseSpeedMultiplier * 1.5;
                    } else {
                         this.monster.speed = this.monster.baseSpeed * baseSpeedMultiplier;
                    }
                    
                    // Animation
                    this.monster.frame += 0.3;
                    if (this.monster.frame >= 4) this.monster.frame = 0;
                    
                    // Monster can only catch player after 3 obstacle hits in recent time
                    if (distanceToPlayer < this.monster.catchDistance && verticalDistance < 25) {
                         // Only catch if player has hit 3 obstacles recently (within 10 seconds)
                         if (this.hitTimestamps && this.hitTimestamps.length >= 3) {
                              this.gameOver();
                         }
                         // If less than 3 hits, monster just follows but cannot catch
                    }
               }
               
               updateClouds() {
                    this.clouds.forEach(cloud => {
                         cloud.x -= cloud.speed;
                         if (cloud.x + cloud.width < 0) {
                              cloud.x = this.canvas.width;
                              cloud.y = Math.random() * 200 + 50;
                         }
                    });
               }
               
               checkCollisions() {
                    // Check obstacle collisions
                    for (let i = this.obstacles.length - 1; i >= 0; i--) {
                         let obstacle = this.obstacles[i];
                         if (this.player.x < obstacle.x + obstacle.width - 5 &&
                             this.player.x + this.player.width - 5 > obstacle.x &&
                             this.player.y < obstacle.y + obstacle.height - 5 &&
                             this.player.y + this.player.height - 5 > obstacle.y) {
                              
                              // Hit obstacle - slow down player
                              this.hitObstacle();
                              
                              // Remove the obstacle after hitting it
                              this.obstacles.splice(i, 1);
                              return;
                         }
                    }
               }
               
               hitObstacle() {
                    // Record the hit
                    let currentTime = Date.now();
                    this.hitTimestamps.push(currentTime);
                    this.lastHitTime = currentTime; // Track the time of the last hit
                    
                    // Remove old timestamps (older than 10 seconds)
                    this.hitTimestamps = this.hitTimestamps.filter(time => 
                         currentTime - time < 10000
                    );
                    
                    // Slow down the game
                    this.gameSpeed = this.baseGameSpeed * 0.5; // Slow down to 50% speed
                    this.slowdownTimer = 180; // 3 seconds at 60fps
                    
                    // After 3 hits, monster becomes deadly (can catch player)
                    // No immediate game over - let the monster catch the player instead
                    
                    // Visual feedback
                    this.showHitEffect();
               }
               
               showHitEffect() {
                    // Flash effect (implemented in draw method)
                    this.hitFlash = 40; // Flash for about 0.7 seconds
               }
               
               updateGameSpeed() {
                    // Gradually restore speed after hitting obstacle
                    if (this.slowdownTimer > 0) {
                         this.slowdownTimer--;
                         if (this.slowdownTimer === 0) {
                              this.gameSpeed = this.baseGameSpeed;
                         }
                    }
               }
               
               updateHitTimestamps() {
                    let currentTime = Date.now();
                    
                    // If 10 seconds have passed since the last hit, reset all hits
                    if (this.lastHitTime > 0 && currentTime - this.lastHitTime >= 10000) {
                         this.hitTimestamps = [];
                         this.lastHitTime = 0;
                    }
                    
                    // Also remove old timestamps (this was already in hitObstacle, but good to double-check)
                    this.hitTimestamps = this.hitTimestamps.filter(time => 
                         currentTime - time < 10000
                    );
               }
               
               gameOver() {
                    this.gameState = 'gameOver';
                    if (this.score > this.highScore) {
                         this.highScore = this.score;
                         localStorage.setItem('highScore', this.highScore);
                    }
                    this.showGameOverScreen();
               }
               
               showGameOverScreen() {
                    document.getElementById('finalScore').textContent = this.score;
                    document.getElementById('finalHighScore').textContent = this.highScore;
                    document.getElementById('gameOverScreen').classList.remove('hidden');
               }
               
               updateScore() {
                    this.score++;
                    document.getElementById('score').textContent = this.score;
                    
                    // Increase difficulty gradually
                    if (this.score % 100 === 0) {
                         this.baseGameSpeed += 0.3;
                         if (this.slowdownTimer === 0) {
                              this.gameSpeed = this.baseGameSpeed;
                         }
                    }
               }
               
               updateHighScore() {
                    document.getElementById('highScore').textContent = this.highScore;
               }
               
               drawPlayer() {
                    const px = this.player.x;
                    const py = this.player.y;
                    const runCycle = Math.sin(this.player.runFrame * 3) * 2;
                    const armSwing = Math.sin(this.player.runFrame * 2.5) * 12;
                    const bobbing = Math.abs(Math.sin(this.player.runFrame * 3)) * 2;
                    
                    // Adjust position for bobbing animation
                    const adjustedY = py - bobbing;
                    
                    // Draw realistic shadow (elliptical)
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.25)';
                    this.ctx.beginPath();
                    this.ctx.ellipse(px + 20, this.ground + 2, 16, 4, 0, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // More realistic leg positioning and animation
                    const legSwing1 = Math.sin(this.player.runFrame * 3) * 8;
                    const legSwing2 = Math.sin(this.player.runFrame * 3 + Math.PI) * 8;
                    const kneeFlexion1 = Math.max(0, Math.sin(this.player.runFrame * 3) * 4);
                    const kneeFlexion2 = Math.max(0, Math.sin(this.player.runFrame * 3 + Math.PI) * 4);
                    
                    // Upper legs (thighs)
                    this.ctx.fillStyle = '#1E3A8A'; // Dark blue pants
                    this.ctx.beginPath();
                    this.ctx.roundRect(px + 12 + legSwing1/2, adjustedY + 40, 6, 15 - kneeFlexion1, 3);
                    this.ctx.fill();
                    this.ctx.beginPath();
                    this.ctx.roundRect(px + 22 + legSwing2/2, adjustedY + 40, 6, 15 - kneeFlexion2, 3);
                    this.ctx.fill();
                    
                    // Lower legs (shins)
                    this.ctx.fillStyle = '#1E40AF'; // Slightly different shade
                    this.ctx.beginPath();
                    this.ctx.roundRect(px + 12 + legSwing1, adjustedY + 50 - kneeFlexion1, 6, 12 + kneeFlexion1, 2);
                    this.ctx.fill();
                    this.ctx.beginPath();
                    this.ctx.roundRect(px + 22 + legSwing2, adjustedY + 50 - kneeFlexion2, 6, 12 + kneeFlexion2, 2);
                    this.ctx.fill();
                    
                    // Realistic torso with slight taper
                    this.ctx.fillStyle = '#3B82F6'; // Blue shirt
                    this.ctx.beginPath();
                    this.ctx.roundRect(px + 10, adjustedY + 20, 20, 22, 4);
                    this.ctx.fill();
                    
                    // Shirt collar
                    this.ctx.fillStyle = '#1E40AF';
                    this.ctx.beginPath();
                    this.ctx.roundRect(px + 16, adjustedY + 20, 8, 4, 2);
                    this.ctx.fill();
                    
                    // Upper arms
                    this.ctx.fillStyle = '#FBBF24'; // More realistic skin tone
                    this.ctx.beginPath();
                    this.ctx.roundRect(px + 6 + armSwing/3, adjustedY + 22, 5, 12, 2.5);
                    this.ctx.fill();
                    this.ctx.beginPath();
                    this.ctx.roundRect(px + 29 - armSwing/3, adjustedY + 22, 5, 12, 2.5);
                    this.ctx.fill();
                    
                    // Forearms
                    this.ctx.fillStyle = '#F59E0B';
                    this.ctx.beginPath();
                    this.ctx.roundRect(px + 5 + armSwing/2, adjustedY + 32, 4, 10, 2);
                    this.ctx.fill();
                    this.ctx.beginPath();
                    this.ctx.roundRect(px + 31 - armSwing/2, adjustedY + 32, 4, 10, 2);
                    this.ctx.fill();
                    
                    // Hands
                    this.ctx.fillStyle = '#FBBF24';
                    this.ctx.beginPath();
                    this.ctx.arc(px + 7 + armSwing/2, adjustedY + 42, 2.5, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.beginPath();
                    this.ctx.arc(px + 33 - armSwing/2, adjustedY + 42, 2.5, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Neck
                    this.ctx.fillStyle = '#FBBF24';
                    this.ctx.beginPath();
                    this.ctx.roundRect(px + 17, adjustedY + 16, 6, 6, 3);
                    this.ctx.fill();
                    
                    // Head with more realistic proportions
                    this.ctx.fillStyle = '#FBBF24'; // Skin tone
                    this.ctx.beginPath();
                    this.ctx.ellipse(px + 20, adjustedY + 10, 11, 13, 0, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Hair with texture
                    this.ctx.fillStyle = '#92400E'; // Brown hair
                    this.ctx.beginPath();
                    this.ctx.ellipse(px + 20, adjustedY + 4, 10, 9, 0, Math.PI * 1.2, Math.PI * 1.8);
                    this.ctx.fill();
                    
                    // Hair strands for texture
                    this.ctx.strokeStyle = '#7C2D12';
                    this.ctx.lineWidth = 1;
                    for (let i = 0; i < 4; i++) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(px + 13 + i * 3, adjustedY + 2);
                        this.ctx.lineTo(px + 14 + i * 3, adjustedY + 8);
                        this.ctx.stroke();
                    }
                    
                    // Eyebrows
                    this.ctx.fillStyle = '#7C2D12';
                    this.ctx.beginPath();
                    this.ctx.ellipse(px + 16, adjustedY + 6, 3, 1, -0.2, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.beginPath();
                    this.ctx.ellipse(px + 24, adjustedY + 6, 3, 1, 0.2, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Eye whites
                    this.ctx.fillStyle = '#FFFFFF';
                    this.ctx.beginPath();
                    this.ctx.ellipse(px + 16, adjustedY + 9, 3, 2, 0, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.beginPath();
                    this.ctx.ellipse(px + 24, adjustedY + 9, 3, 2, 0, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Irises
                    this.ctx.fillStyle = '#059669'; // Green eyes
                    this.ctx.beginPath();
                    this.ctx.arc(px + 16, adjustedY + 9, 1.5, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.beginPath();
                    this.ctx.arc(px + 24, adjustedY + 9, 1.5, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Pupils
                    this.ctx.fillStyle = '#000000';
                    this.ctx.beginPath();
                    this.ctx.arc(px + 16, adjustedY + 9, 1, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.beginPath();
                    this.ctx.arc(px + 24, adjustedY + 9, 1, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Eye shine/reflection
                    this.ctx.fillStyle = '#FFFFFF';
                    this.ctx.beginPath();
                    this.ctx.arc(px + 16.5, adjustedY + 8.5, 0.5, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.beginPath();
                    this.ctx.arc(px + 24.5, adjustedY + 8.5, 0.5, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Nose
                    this.ctx.fillStyle = '#F59E0B';
                    this.ctx.beginPath();
                    this.ctx.ellipse(px + 20, adjustedY + 11, 1, 2, 0, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Nostrils
                    this.ctx.fillStyle = '#D97706';
                    this.ctx.beginPath();
                    this.ctx.arc(px + 19, adjustedY + 12, 0.5, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.beginPath();
                    this.ctx.arc(px + 21, adjustedY + 12, 0.5, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Mouth with more detail
                    this.ctx.fillStyle = '#DC2626';
                    this.ctx.beginPath();
                    this.ctx.ellipse(px + 20, adjustedY + 15, 3, 1.5, 0, 0, Math.PI);
                    this.ctx.fill();
                    
                    // Lip line
                    this.ctx.strokeStyle = '#B91C1C';
                    this.ctx.lineWidth = 0.5;
                    this.ctx.beginPath();
                    this.ctx.arc(px + 20, adjustedY + 15, 3, 0, Math.PI);
                    this.ctx.stroke();
                    
                    // Ears
                    this.ctx.fillStyle = '#FBBF24';
                    this.ctx.beginPath();
                    this.ctx.ellipse(px + 9, adjustedY + 10, 2, 3, 0, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.beginPath();
                    this.ctx.ellipse(px + 31, adjustedY + 10, 2, 3, 0, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Athletic shoes with detail
                    this.ctx.fillStyle = '#1F2937'; // Dark gray shoes
                    this.ctx.beginPath();
                    this.ctx.roundRect(px + 10 + legSwing1, adjustedY + 58, 12, 7, 3);
                    this.ctx.fill();
                    this.ctx.beginPath();
                    this.ctx.roundRect(px + 18 + legSwing2, adjustedY + 58, 12, 7, 3);
                    this.ctx.fill();
                    
                    // Shoe laces
                    this.ctx.strokeStyle = '#FFFFFF';
                    this.ctx.lineWidth = 1;
                    this.ctx.beginPath();
                    this.ctx.moveTo(px + 14 + legSwing1, adjustedY + 60);
                    this.ctx.lineTo(px + 18 + legSwing1, adjustedY + 62);
                    this.ctx.stroke();
                    this.ctx.beginPath();
                    this.ctx.moveTo(px + 22 + legSwing2, adjustedY + 60);
                    this.ctx.lineTo(px + 26 + legSwing2, adjustedY + 62);
                    this.ctx.stroke();
                    
                    // Shoe soles
                    this.ctx.fillStyle = '#000000';
                    this.ctx.beginPath();
                    this.ctx.roundRect(px + 9 + legSwing1, adjustedY + 64, 14, 2, 1);
                    this.ctx.fill();
                    this.ctx.beginPath();
                    this.ctx.roundRect(px + 17 + legSwing2, adjustedY + 64, 14, 2, 1);
                    this.ctx.fill();
               }
               
               drawObstacles() {
                    this.obstacles.forEach(obstacle => {
                         if (obstacle.type === 'cactus') {
                              this.ctx.fillStyle = '#10B981';
                              this.ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                              // Cactus arms
                              this.ctx.fillRect(obstacle.x - 8, obstacle.y + 10, 15, 8);
                              this.ctx.fillRect(obstacle.x + obstacle.width - 7, obstacle.y + 15, 15, 8);
                         } else {
                              this.ctx.fillStyle = '#6B7280';
                              this.ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                         }
                    });
               }
               
               drawMonster() {
                    if (!this.monster) return;
                    
                    let monster = this.monster;
                    let isDeadly = this.hitTimestamps && this.hitTimestamps.length >= 3;
                    const mx = monster.x;
                    const my = monster.y;
                    const bounce = Math.sin(monster.frame * 1.5) * 4;
                    const breathe = Math.sin(monster.frame * 0.8) * 2;
                    
                    // Draw monster shadow
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    this.ctx.fillRect(mx - 2, this.ground - 2, monster.width + 4, 4);
                    
                    // Monster body - main torso with irregular shape
                    if (isDeadly) {
                         this.ctx.fillStyle = this.slowdownTimer > 0 ? '#1A0000' : '#2D1B1B';
                    } else {
                         this.ctx.fillStyle = this.slowdownTimer > 0 ? '#4A1515' : '#7F2020';
                    }
                    
                    // Main body (irregular shape)
                    this.ctx.beginPath();
                    this.ctx.moveTo(mx + 5, my + 15 + bounce);
                    this.ctx.lineTo(mx + 30, my + 15 + bounce);
                    this.ctx.lineTo(mx + 32, my + 35 + bounce);
                    this.ctx.lineTo(mx + 28, my + 45 + bounce);
                    this.ctx.lineTo(mx + 7, my + 45 + bounce);
                    this.ctx.lineTo(mx + 3, my + 35 + bounce);
                    this.ctx.closePath();
                    this.ctx.fill();
                    
                    // Monster head (larger and more menacing)
                    if (isDeadly) {
                         this.ctx.fillStyle = this.slowdownTimer > 0 ? '#000000' : '#1A0A0A';
                    } else {
                         this.ctx.fillStyle = this.slowdownTimer > 0 ? '#2D0000' : '#450A0A';
                    }
                    
                    // Head shape (more skull-like)
                    this.ctx.beginPath();
                    this.ctx.ellipse(mx + 17, my + 8 + bounce + breathe, 16, 12, 0, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Monster horns/spikes
                    this.ctx.fillStyle = isDeadly ? '#800000' : '#600000';
                    this.ctx.beginPath();
                    this.ctx.moveTo(mx + 8, my + 2 + bounce);
                    this.ctx.lineTo(mx + 12, my - 3 + bounce);
                    this.ctx.lineTo(mx + 15, my + 4 + bounce);
                    this.ctx.closePath();
                    this.ctx.fill();
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(mx + 20, my + 4 + bounce);
                    this.ctx.lineTo(mx + 23, my - 3 + bounce);
                    this.ctx.lineTo(mx + 27, my + 2 + bounce);
                    this.ctx.closePath();
                    this.ctx.fill();
                    
                    // Monster arms/claws
                    this.ctx.fillStyle = isDeadly ? '#2D0505' : '#4A1010';
                    const armSwing = Math.sin(monster.frame * 1.2) * 3;
                    
                    // Left arm
                    this.ctx.beginPath();
                    this.ctx.roundRect(mx + 2 + armSwing, my + 18 + bounce, 8, 20, 2);
                    this.ctx.fill();
                    
                    // Right arm  
                    this.ctx.beginPath();
                    this.ctx.roundRect(mx + 25 - armSwing, my + 18 + bounce, 8, 20, 2);
                    this.ctx.fill();
                    
                    // Claws
                    this.ctx.fillStyle = '#CCCCCC';
                    this.ctx.fillRect(mx + 1 + armSwing, my + 35 + bounce, 3, 6);
                    this.ctx.fillRect(mx + 5 + armSwing, my + 37 + bounce, 3, 4);
                    this.ctx.fillRect(mx + 29 - armSwing, my + 35 + bounce, 3, 6);
                    this.ctx.fillRect(mx + 26 - armSwing, my + 37 + bounce, 3, 4);
                    
                    // Monster legs
                    this.ctx.fillStyle = isDeadly ? '#1A0505' : '#3D0A0A';
                    this.ctx.beginPath();
                    this.ctx.roundRect(mx + 8, my + 42 + bounce, 8, 15, 2);
                    this.ctx.fill();
                    this.ctx.beginPath();
                    this.ctx.roundRect(mx + 19, my + 42 + bounce, 8, 15, 2);
                    this.ctx.fill();
                    
                    // Eyes - glowing effect
                    if (isDeadly) {
                         // Deadly monster - bright glowing red eyes
                         this.ctx.fillStyle = '#FF0000';
                         this.ctx.shadowColor = '#FF0000';
                         this.ctx.shadowBlur = 8;
                    } else {
                         // Normal monster - yellow/orange eyes
                         this.ctx.fillStyle = this.slowdownTimer > 0 ? '#FFD700' : '#FFA500';
                         this.ctx.shadowColor = this.slowdownTimer > 0 ? '#FFD700' : '#FFA500';
                         this.ctx.shadowBlur = 4;
                    }
                    
                    // Left eye
                    this.ctx.beginPath();
                    this.ctx.arc(mx + 11, my + 6 + bounce + breathe, 4, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Right eye
                    this.ctx.beginPath();
                    this.ctx.arc(mx + 23, my + 6 + bounce + breathe, 4, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Eye pupils
                    this.ctx.shadowBlur = 0;
                    this.ctx.fillStyle = '#000000';
                    this.ctx.beginPath();
                    this.ctx.arc(mx + 11, my + 6 + bounce + breathe, 2, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.beginPath();
                    this.ctx.arc(mx + 23, my + 6 + bounce + breathe, 2, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Mouth/teeth
                    this.ctx.fillStyle = '#000000';
                    this.ctx.beginPath();
                    this.ctx.ellipse(mx + 17, my + 12 + bounce + breathe, 6, 3, 0, 0, Math.PI);
                    this.ctx.fill();
                    
                    // Teeth
                    this.ctx.fillStyle = '#FFFFFF';
                    for (let i = 0; i < 4; i++) {
                         this.ctx.beginPath();
                         this.ctx.moveTo(mx + 13 + i * 2, my + 12 + bounce + breathe);
                         this.ctx.lineTo(mx + 14 + i * 2, my + 9 + bounce + breathe);
                         this.ctx.lineTo(mx + 15 + i * 2, my + 12 + bounce + breathe);
                         this.ctx.closePath();
                         this.ctx.fill();
                    }
                    
                    // Draw danger indicator when close
                    let distanceToPlayer = Math.abs(monster.x - this.player.x);
                    if (distanceToPlayer < 120) {
                         if (isDeadly) {
                              // Deadly monster - bright red pulsing line
                              this.ctx.strokeStyle = '#FF0000';
                              this.ctx.lineWidth = 4;
                              this.ctx.setLineDash([6, 2]);
                              this.ctx.shadowColor = '#FF0000';
                              this.ctx.shadowBlur = 6;
                         } else {
                              // Normal chasing - less threatening yellow/orange line
                              this.ctx.strokeStyle = this.slowdownTimer > 0 ? '#FFA500' : '#FFD700';
                              this.ctx.lineWidth = 2;
                              this.ctx.setLineDash([12, 8]);
                              this.ctx.shadowBlur = 2;
                         }
                         this.ctx.beginPath();
                         this.ctx.moveTo(monster.x + monster.width/2, monster.y + 10);
                         this.ctx.lineTo(this.player.x + this.player.width/2, this.player.y + 10);
                         this.ctx.stroke();
                         this.ctx.setLineDash([]);
                         this.ctx.shadowBlur = 0;
                    }
               }
               
               drawClouds() {
                    this.clouds.forEach(cloud => {
                         this.ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                         this.ctx.fillRect(cloud.x, cloud.y, cloud.width, cloud.height);
                         this.ctx.fillRect(cloud.x + 10, cloud.y - 10, cloud.width - 20, cloud.height);
                         this.ctx.fillRect(cloud.x + 15, cloud.y + 10, cloud.width - 30, cloud.height - 10);
                    });
               }
               
               drawGround() {
                    this.ctx.fillStyle = '#22C55E';
                    this.ctx.fillRect(0, this.ground, this.canvas.width, this.canvas.height - this.ground);
                    
                    // Ground pattern
                    this.ctx.fillStyle = '#16A34A';
                    for (let i = 0; i < this.canvas.width; i += 50) {
                         let offset = (i + this.score) % 100;
                         this.ctx.fillRect(offset, this.ground, 25, 10);
                    }
               }
               
               update() {
                    if (this.gameState !== 'playing') return;
                    
                    this.updatePlayer();
                    this.spawnObstacle();
                    this.updateObstacles();
                    this.updateMonster();
                    this.updateClouds();
                    this.updateGameSpeed();
                    this.checkCollisions();
                    this.updateHitTimestamps(); // Check for hit reset
                    this.updateUI();
                    
                    // Update score every few frames
                    if (this.score % 3 === 0) {
                         this.updateScore();
                    }
               }
               
               updateUI() {
                    // Update hit counter safely
                    const hitCountElement = document.getElementById('obstacleHits');
                    if (hitCountElement) {
                         hitCountElement.textContent = this.hitTimestamps ? this.hitTimestamps.length : 0;
                    }
                    
                    // Update slowdown indicator
                    const slowdownIndicator = document.getElementById('slowdownIndicator');
                    if (slowdownIndicator) {
                         if (this.slowdownTimer > 0) {
                              slowdownIndicator.classList.remove('hidden');
                         } else {
                              slowdownIndicator.classList.add('hidden');
                         }
                    }
               }
               
               draw() {
                    // Clear canvas with sky gradient
                    const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
                    gradient.addColorStop(0, '#87CEEB');
                    gradient.addColorStop(1, '#98FB98');
                    this.ctx.fillStyle = gradient;
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    
                    // Hit flash effect
                    if (this.hitFlash && this.hitFlash > 0) {
                         this.ctx.fillStyle = `rgba(255, 0, 0, ${this.hitFlash / 60})`;
                         this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                         this.hitFlash--;
                    }
                    
                    this.drawClouds();
                    this.drawGround();
                    this.drawObstacles();
                    this.drawMonster();
                    this.drawPlayer();
               }
               
               gameLoop() {
                    this.update();
                    this.draw();
                    requestAnimationFrame(() => this.gameLoop());
               }
          }
          
          // Start the game when page loads
          window.addEventListener('load', () => {
               new EndlessRunner();
          });
          
          // Handle window resize
          window.addEventListener('resize', () => {
               const canvas = document.getElementById('gameCanvas');
               canvas.width = window.innerWidth;
               canvas.height = window.innerHeight;
          });
     </script>
</body>
</html>